local set = require("shark/util/set")

local GraphController = {
    padding = { left = 0.1, right = 0.1, top = 0.1, bottom = 0.1 },
    scale = Vector(8.29, 0.59, 8.29),
    curve_displacement = 0.05,
    default_visible_turns = 20,
    scroll_factor = 1 / 3,
}

GraphController.ref_1 = Vector{
    x = -1 + 2 * GraphController.padding.left,
    y = 1,
    z = -1 + 2 * GraphController.padding.bottom,
}:scale(GraphController.scale)

GraphController.ref_2 = Vector{
    x = 1 - 2 * GraphController.padding.right,
    y = 1,
    z = 1 - 2 * GraphController.padding.top,
}:scale(GraphController.scale)

GraphController.ref_delta = GraphController.ref_2 - GraphController.ref_1

GraphController.__index = GraphController

function GraphController.init(objects, game)
    local instance = {
        objects = objects,
        game = game,
        data = {},
        objects_data = {},
    }

    setmetatable(instance, GraphController)

    for _, company in ipairs(game.companies) do
        instance.data[company] = { 0 }
    end

    for _, object in ipairs(objects) do
        instance.objects_data[object.guid] = {
            turn_offset = 0,
            visible_turns = instance.default_visible_turns,
        }

        object.createButton({
            label = '<',
            click_function = 'GraphController_onScrollLeftClick',
            position = { 4, 0.25, -11.5 },
            scale = { 2, 2, 2 },
            rotation = { 0, 180, 0 },
            width = 800,
            height = 800,
            font_size = 500,
        })

        object.createButton({
            label = '>',
            click_function = 'GraphController_onScrollRightClick',
            position = { 0, 0.25, -11.5 },
            scale = { 2, 2, 2 },
            rotation = { 0, 180, 0 },
            width = 800,
            height = 800,
            font_size = 500,
        })

        object.createButton({
            label = '>|',
            click_function = 'GraphController_onScrollEndClick',
            position = { -4, 0.25, -11.5 },
            scale = { 2, 2, 2 },
            rotation = { 0, 180, 0 },
            width = 800,
            height = 800,
            font_size = 500,
        })

        object.createButton({
            label = '-',
            click_function = 'GraphController_onZoomOutClick',
            position = { 4, 0.25, 11.5 },
            scale = { 2, 2, 2 },
            rotation = { 0, 180, 0 },
            width = 800,
            height = 800,
            font_size = 500,
        })

        object.createButton({
            label = '0',
            click_function = 'GraphController_onZoomResetClick',
            position = { 0, 0.25, 11.5 },
            scale = { 2, 2, 2 },
            rotation = { 0, 180, 0 },
            width = 800,
            height = 800,
            font_size = 500,
        })

        object.createButton({
            label = '+',
            click_function = 'GraphController_onZoomInClick',
            position = { -4, 0.25, 11.5 },
            scale = { 2, 2, 2 },
            rotation = { 0, 180, 0 },
            width = 800,
            height = 800,
            font_size = 500,
        })

        object.createButton({
            label = "Clear\nData",
            click_function = 'GraphController_onClearDataClick',
            position = { -11.5, 0.25, -7 },
            scale = { 2, 2, 2 },
            rotation = { 0, 180, 0 },
            width = 800,
            height = 800,
            font_size = 200,
        })
    end

    -- DEBUG
    for i = 1, 40 do
        -- print(i)
        local profit_company = game.companies[math.random(#game.companies)]

        for _, company in ipairs(game.companies) do
            if company == profit_company then
                instance.data[company][i + 1] = instance.data[company][i] + 1
            else
                instance.data[company][i + 1] = instance.data[company][i]
            end
        end
    end

    GraphController.instance = instance

    return instance
end

-- events

function GraphController_onScrollLeftClick(object, player_color, alt_click)
    local graph = GraphController.instance
    local visible_turns = graph:getVisibleTurns(object.guid)
    local delta = -math.round(visible_turns * graph.scroll_factor)

    if graph:scrollBy(object.guid, delta) then
        graph:render(object)
    end
end

function GraphController_onScrollRightClick(object, player_color, alt_click)
    local graph = GraphController.instance
    local visible_turns = graph:getVisibleTurns(object.guid)
    local delta = math.round(visible_turns * graph.scroll_factor)

    if graph:scrollBy(object.guid, delta) then
        graph:render(object)
    end
end

function GraphController_onScrollEndClick(object, player_color, alt_click)
    local graph = GraphController.instance
    local rightmost = graph:getRightmostTurn(object.guid)

    if graph:scrollTo(object.guid, rightmost) then
        graph:render(object)
    end
end

function GraphController_onZoomOutClick(object, player_color, alt_click)

end

function GraphController_onZoomResetClick(object, player_color, alt_click)

end

function GraphController_onZoomInClick(object, player_color, alt_click)

end

function GraphController_onClearDataClick(object, player_color, alt_click)

end

-- methods

function GraphController:getTurns()
    return #self.data[self.game.companies[1]]
end

function GraphController:getTurnOffset(object_guid)
    return self.objects_data[object_guid].turn_offset
end

function GraphController:getVisibleTurns(object_guid)
    return self.objects_data[object_guid].visible_turns
end

function GraphController:getLeftmostTurn(object_guid)
    return 0
end

function GraphController:getRightmostTurn(object_guid)
    local visible_turns = self:getVisibleTurns(object_guid)
    local turns = self:getTurns()

    return math.max(0, turns - visible_turns)
end

function GraphController:isLeftmost(object_guid)
    local turn_offset = self:getVisibleTurns(object_guid)
    local leftmost = self:getLeftmostTurn(object_guid)

    return turn_offset <= leftmost
end

function GraphController:isRightmost(object_guid)
    local turn_offset = self:getTurnOffset(object_guid)
    local rightmost = self:getRightmostTurn(object_guid)

    return turn_offset >= rightmost
end

function GraphController:push(data)
    local rightmost = set.new{}

    -- memorize rightmost objects
    for object_guid, object_data in pairs(self.objects_data) do
        if self:isRightmost(object_guid) then
            set.add(rightmost, object_guid)
        end
    end

    -- insert data
    for company, share_price in pairs(data) do
        table.insert(self.data[company], share_price)
    end

    -- scroll objects to the right that were rightmost previously
    for object_guid in set.each(rightmost) do
        self:scrollBy(object_guid, 1)
    end
end

function GraphController:updateLast(data)
    local index = self:getTurn() + 1

    for company, share_price in pairs(data) do
        self.data[company][index] = share_price
    end
end

-- Returns whether the view has actually been changed.
function GraphController:scrollTo(object_guid, turn_offset)
    local object_data = self.objects_data[object_guid]

    if turn_offset < object_data.turn_offset then
        local leftmost = self:getLeftmostTurn(object_guid)

        if leftmost >= object_data.turn_offset then
            return false
        end

        object_data.turn_offset = math.max(turn_offset, leftmost)

        return true
    elseif turn_offset > object_data.turn_offset then
        local rightmost = self:getRightmostTurn(object_guid)

        if rightmost <= object_data.turn_offset then
            return false
        end

        object_data.turn_offset = math.min(turn_offset, rightmost)

        return true
    end

    -- no change: turn_offset == object_data.turn_offset

    return false
end

function GraphController:scrollBy(object_guid, delta)
    local turn_offset = self:getTurnOffset(object_guid) + delta

    return self:scrollTo(object_guid, turn_offset)
end

function GraphController:renderAll()
    for _, object in ipairs(self.objects) do
        self:render(object)
    end
end

function GraphController:render(object)
    local object_data = self.objects_data[object.guid]
    local turn_offset = object_data.turn_offset
    local visible_turns = object_data.visible_turns

    local vector_lines = {}

    -- axes
    table.insert(vector_lines, {
        points = self:projectDataPoints({
            { 0, self.game.share_price.max },
            { 0, 0 },
            { 0 + visible_turns - 1, 0 }
        }, object.guid)
    })

    -- company share price curves
    for i, company in ipairs(self.game.companies) do
        local displacement = i * self.curve_displacement
        local points = table.collect(self.data[company], function (share_price, j)
            local x = j - 1 - turn_offset
            local y = share_price + displacement

            return { x, y }
        end, turn_offset + 1, turn_offset + visible_turns)

        table.insert(vector_lines, 1, {
            points = self:projectDataPoints(points, object.guid),
            color = self.game.company_colors[company],
        })
    end

    object.setVectorLines(vector_lines)
end

function GraphController:projectDataPoints(points, object_guid)
    local object_data = self.objects_data[object_guid]
    local visible_turns = object_data.visible_turns

    return table.collect(points, function (point)
        local temp = Vector(point[1] / (visible_turns - 1), 1, point[2] / self.game.share_price.max)
        return self.ref_1 + temp:scale(self.ref_delta)
    end)
end

return GraphController
